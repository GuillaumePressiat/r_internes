---
title: 'Cours 1 : Les fonctions'
output: 
  ioslides_presentation:
    smaller : true
    css : slides.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "#")
```

## Sources {#cover}

La **TRES** grande majorité des informations données ici sont issues du livre de Hadley Wickham : **Advanced R**.

Clairement la référence (en Anglais !) en "vulgarisation" des fonctionnalités avancées de R.

<div class="centered">
![](img/AdvancedR.jpg)

[http://adv-r.had.co.nz/](http://adv-r.had.co.nz/)
</div>

Livre consultable intégralement en ligne, ou achetable sur internet (Amazon...)

## Une fonction : présentation simple

Dans R, **une fonction est un objet**, au même titre qu'un vecteur, un dataframe, une liste...
Dans R, **tout est fonction dans R**, y compris '`+`' ou '`(`' ou encore '`if`'.

Une fonction permet de créer une version abstraite et réutilisable d'une solution que l'on souhaite appliquer à un problème donné.

Exemple de fonction basique:
```{r}
# Fonction renvoyant le carré d'une valeur
f <- function(x) {
  x^2
}
```

Exemple d'utilisation (= appel de la fonction) :
```{r}
f(2)
```

Une fonction retourne une valeur, c'est souvent la raison d'être de la fonction.

## Pourquoi utiliser des fonctions ?

### Grande facilité à réutiliser son code

Créer une fonction permet de **"s'extraire" du contexte** dans laquelle elle est créée.

On ne cherche plus à résoudre un problème précis, mais un **problème générique** : la fonction pourra être réutilisée dès qu'on sera confronté au même type de problème.

### Meilleure lisibilité

Le code est plus compact : toute la partie reproductible est encapsulée dans la fonction. Il ne reste qu'à passer les arguments et à manipuler la sortie.

### Maintenance plus aisée

La correction d'un bug au niveau d'une fonction permet de corriger le problème simultanément à tous les endroits où elle est utilisée (y compris dans d'autres projets par exemple).

Des outils type `debug()` permettent aussi d'explorer plus finement le comportement d'une fonction, et de trouver souvent la source d'un problème.

[http://www.burns-stat.com/bricks-not-monoliths/](http://www.burns-stat.com/bricks-not-monoliths/)

## Exemple d'utilisation {.reduceCode}

Code monolithique :
```{r}
# transform data
# fit model to data
# plot data
# get desired model results
```
Fonction monolithique :
```{r}
monolith <- function(data) {
        # transform data
        # fit model to data
        # plot data
        # get desired model results
}
```
Fonction en briques :
```{r}
brickwall <- function(data) {
        tranData <- myDataTransform(data)
        dataMod <- myModelFit(tranData)
        myPlot(dataMod)
        myModelOutput(dataMod)
}
```

## Les constituants d'une fonction {.reduceCode}

Une fonction est constitué de **3 principaux éléments** :

- Le **corps** : la définition de la fonction, accessible via `body()`.
```{r}
body(f)
```
- Les **arguments** : les paramètres qui sont utilisés par la fonction, accessible via `formals()`.
```{r}
formals(f)
```
- L'**environnement** : le contexte dans lequel la fonction est définie, accessible via `environment()`.
```{r}
environment(f)
```

## Les environnements

```{r}
x <- 3
varName <- "foo"
```

En `R` les noms d'objets (`x`, `varName`...) sont liés à des valeurs (`3`, `"foo"`...). Ces informations sont contenues dans un *environnement* (une sorte de "sac de noms").

Par exemple l'environnement où on travaille quand on ouvre `R` est l'environnement global. Mais il peut exister d'autres environnements.

Chaque fonction utilise 3 environnements : *enclosing*, *execution*, *calling*.

## Execution environment

Quand une fonction est lancée, le code contenu dans le corps est éxécuté dans un nouvel environnement, créé *de novo*.

Sauf exception, cet environnement est détruit et les données sont perdues quand la fonction est finie.

```{r error = TRUE}
f <- function() {
  variable <- 42
  variable
}

f()

variable
```

## Enclosing environment {.reduceCode}

C'est l'environnement où la fonction a été *définie*. Pour une fonction définie classiquement, c'est donc l'environnement global.

Mais il est possible que ça soit un autre environnement, par exemple l'*execution environment* d'une autre fonction (quand une deuxième fonction est définie dans une première fonction).

```{r}
f <- function() {
  g <- function(y) y^2
  environment(g)
}
```
L'*enclosing environment* de `f()` est l'environement global.
```{r}
environment(f)
```
L'*enclosing environment* de `g()` est l'*execution environment* de `f()`.
```{r}
f()
```

## Calling environment

C'est tout simplement l'environnement où la fonction est lancée. On peut l'obtenir avec `parent.frame()`.

```{r}
f <- function() {
  parent.frame()
}
```
Ici c'est donc l'environnement global:
```{r}
f()
```
Mais pour cette même fonction `f()`, si elle est lancée depuis `g()`, ça peut aussi être l'*execution environment* de `g()`.
```{r}
g <- function() {
  f()
}
g()
```

## Le lexical scoping

Ensemble de règles permettant à `R` de faire correspondre une valeur à un symbole.
```{r}
x <- 10
f <- function() {
  x <- 20
  x
}

x
f()
  
```

## Le lexical scoping

- Pacours des environnements

- Fonctions VS variables

- Variables éphémères

- Evaluation à l'exécution

Dynamic lookup + lazy evaluation

## La gestion des arguments

- Les arguments (formels et valeurs remplacées par exécution : appels)
- Les valeurs par défaut

## Les arguments

- Par leur nom complet
- Par leur nom partiel
- Par leur position (ordre dans la définition de la fonction)


## Les arguments
```{r}
f <- function(foo, bar) {
  c(foo, bar)
}
```

Possiblité de donner les argument en :

- Utilisant leurs noms complets
```{r, results='hide'}
f(foo = 1 , bar = 2)
```

- Utilisant une partie de leur nom (*partial matching*)
```{r, results='hide'}
f(f = 1, b = 2)
```

- Utilisant leur position dans la définition de la fonction
```{r, results='hide'}
f(1, 2)
```

## Manipulation des arguments {.reduceCode}

Récupération de la liste des arguments avec `formals()`.
```{r}
formals(sample)
```
Test sur la présence/absence d'un argument avec `missing()`.

## Lazy evaluation
L'évaluation d'un argument ne se fait qu'à l'instant *t* où l'argument est utilisé dans le corps de la fonction (et donc à l'instant *t* où l'évaluation devient nécessaire).
 
```{r}
f <- function(a = 1 , b = a * 2) {
  a <- 6
  b
}
```

L'évaluation de `b` ne se fait qu'au moment de son utilisation 
(donc ici après l'affectation de la valeur 6 à `a`)
```{r}
f()
```

## Dot Dot Dot (`...`) (1)

Argument spécial `...` qui permet de passer des arguments non spécifiés/déterminés à l'avance.

Utile dans deux cas :

- travailler sur un nombre arbitraire d'arguments.
```{r}
all_numeric <- function(...) {
  arguments <- list(...)
  all(unlist(lapply(arguments, is.numeric)))
}
all_numeric(2, c(1, 2, 3), 4:8)
```

## Dot Dot Dot (`...`) (2)

- faire passer des arguments à une fonction exécutée à l'intérieur d'une autre fonction, sans avoir à tous les nommer.
```{r}
mult_and_resamp <- function(x, y, ...) {
  x2 <- x * y
  sample(x2, ...)
}
mult_and_resamp(0:5, 10)
mult_and_resamp(0:2, 2, replace = TRUE, size = 10)
```

## Valeur de retour {.reduceCode}
Par défaut, une fonction retourne un objet **unique** qui peut être :

- le résultat de la dernière évaluation.
```{r}
f <- function(x) {
  x^2
}
f(2)
```
- un résultat précis, choisi, par l'intermédiaire de `return()` (force l'arrêt de la fonction).
```{r}
f <- function(x){
  if(x%%2 == 0){
    return("x est un nombre pair")
  }
  "x est un nombre impair"
}
f(4)
```

## Valeurs de retour complexes (1) {.reduceCode}

Comment faire pour retourner plus de choses ? Deux solutions :

- Tout mettre dans une liste.
```{r}
some_stats <- function(x) {
  list(
    moyenne = mean(x),
    etendue = range(x),
    test = t.test(x)
  )
}
some_stats(rnorm(10))
```

## Valeurs de retour complexes (2) {.reduceCode}

- Utiliser des attributs.
```{r}
impute_mean <- function(x) {
  res <- x
  res[is.na(x)] <- mean(x, na.rm = TRUE)
  
  attr(res, "imputed") <- is.na(x)
  res
}

(test <- impute_mean(c(1, 2, NA, 3)))
attr(test, "imputed")
```
Avantage: le résultat continue à se comporter comme l'objet original (ici un vecteur), ce qui est parfois plus facile à utiliser qu'une liste.

## Définir plus facilement des attributs

Avec la fonction structure il est plus facile d'ajouter des attributs.
```{r}
f <- function(x) {
  res <- mean(x, na.rm = TRUE)
  
  structure(
    res,
    original_length = length(x),
    n_na = sum(is.na(x))
  )
}
f(c(1, 3, NA))
```

## Closures (1)
Le résultat d'une fonction est un objet. Une fonction est un objet comme un autre.

Une fonction peut donc renvoyer une autre fonction : ce sont les **closures**.
```{r}
f <- function(x){
  g <- function(y){
    x^y
  }
}
```

```{r}
carre <- f(2)
carre(2)

cube <- f(3)
cube(2)
```

## Closures (2)

Un exemple plus appliqué : un rééchantilloneur.
```{r}
create_resampler <- function(x) {
  function(n) sample(x, size = n, replace = TRUE)
}
rs1 <- create_resampler(1:10)
rs1(2)
rs1(9)
rs2 <- create_resampler(c("M", "F"))
rs2(5)
```

## Une fonction argument d'une fonction

On peut passer une fonction comme argument à une autre fonction. Ce concept est fondamental pour le cours suivant sur la famille de fonctions `apply()`.

```{r}
do_something_to_x <- function(x, func) {
  func(x)
}
do_something_to_x(1:10, mean)
do_something_to_x(1:10, range)
```

## Pour combiner les concepts (1) {.reduceCode}

Closure + *enclosing environment* + scoping. On fait un compteur.
```{r}
create_counter <- function() {
  n <- 0
  function() {
    n <<- n + 1
    return(n)
  }
}
c1 <- create_counter()
c1()
c1()
```
Pas partagé car si on appelle à nouveau `create_counter()`, un second *execution environment* indépendant est créé.
```{r}
c2 <- create_counter()
c2()
c1()
```

## Pour combiner les concepts (2) {.reduceCode}

Il faut remonter d'un cran l'*enclosing environment*.
```{r}
# local() permet de créer un nouvel environment
create_counter <- local({
  n <- 0
  function() {
    function() {
      n <<- n + 1
      return(n)
    }
  }
})
c1 <- create_counter()
c1()
c2 <- create_counter()
c2()
c1()
```
