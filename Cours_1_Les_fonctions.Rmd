---
title: 'Cours 1 : Les fonctions'
output: 
  ioslides_presentation:
    smaller : true
    css : slides.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "#")
```

## Sources {#cover}

La **TRES** grande majorité des informations données ici sont issues du livre de Hadley Wickham : **Advanced R**.

Clairement la référence (en Anglais !) en "vulgarisation" des fonctionnalités avancées de `R`.

<div class="centered">
![](img/AdvancedR.jpg)

[http://adv-r.had.co.nz/](http://adv-r.had.co.nz/)
</div>

Livre consultable intégralement en ligne, ou achetable sur internet (Amazon, etc).

## Une fonction : présentation simple

Dans `R`, **une fonction est un objet**, au même titre qu'un vecteur, un dataframe, une liste...
Dans `R`, **tout est fonction dans `R`**, y compris '`+`' ou '`(`' ou encore '`if`'.

Une fonction permet de créer une version abstraite et réutilisable d'une solution que l'on souhaite appliquer à un problème donné.

Exemple de fonction basique:
```{r}
# Fonction renvoyant le carré d'une valeur
f <- function(x) {
  x^2
}
```

Exemple d'utilisation (= appel de la fonction) :
```{r}
f(2)
```

Une fonction retourne une valeur, c'est souvent la raison d'être de la fonction.

## Pourquoi utiliser des fonctions ?

### Grande facilité à réutiliser son code

Créer une fonction permet de **"s'extraire" du contexte** dans laquelle elle est créée.

On ne cherche plus à résoudre un problème précis, mais un **problème générique** : la fonction pourra être réutilisée dès qu'on sera confronté au même type de problème.

### Meilleure lisibilité

Le code est plus compact : toute la partie reproductible est encapsulée dans la fonction. Il ne reste qu'à passer les arguments et à manipuler la sortie.

### Maintenance plus aisée

La correction d'un bug au niveau d'une fonction permet de corriger le problème simultanément à tous les endroits où elle est utilisée (y compris dans d'autres projets par exemple).

Des outils type `debug()` permettent aussi d'explorer plus finement le comportement d'une fonction, et de trouver souvent la source d'un problème.

[http://www.burns-stat.com/bricks-not-monoliths/](http://www.burns-stat.com/bricks-not-monoliths/)

## Exemple d'utilisation {.reduceCode}

Code monolithique :
```{r}
# transform data
# fit model to data
# plot data
# get desired model results
```
Fonction monolithique :
```{r}
monolith <- function(data) {
        # transform data
        # fit model to data
        # plot data
        # get desired model results
}
```
Fonction en briques :
```{r}
brickwall <- function(data) {
        tranData <- myDataTransform(data)
        dataMod <- myModelFit(tranData)
        myPlot(dataMod)
        myModelOutput(dataMod)
}
```

## Les constituants d'une fonction {.reduceCode}

Une fonction est constitué de **3 principaux éléments** :

- Le **corps** : la définition de la fonction, accessible via `body()`.
```{r}
body(f)
```
- Les **arguments** : les paramètres qui sont utilisés par la fonction, accessible via `formals()`.
```{r}
formals(f)
```
- L'**environnement** : le contexte dans lequel la fonction est définie, accessible via `environment()`.
```{r}
environment(f)
```

## Les environnements

```{r}
x <- 3
varName <- "foo"
```

En `R` les noms d'objets (`x`, `varName`...) sont liés à des valeurs (`3`, `"foo"`...). Ces informations sont contenues dans un *environnement* (une sorte de "sac de noms").

Par exemple l'environnement où on travaille quand on ouvre `R` est l'environnement global. Mais il peut exister d'autres environnements.

Chaque fonction utilise 3 environnements : *enclosing*, *execution*, *calling*.

## Execution environment

Quand une fonction est lancée, le code contenu dans le corps est executé dans un nouvel environnement, créé *de novo*.

Sauf exception, cet environnement est détruit et les données sont perdues quand la fonction est finie.

```{r error = TRUE}
f <- function() {
  variable <- 42
  variable
}

f()

variable
```

## Enclosing environment {.reduceCode}

C'est l'environnement où la fonction a été *définie*. Pour une fonction définie classiquement, c'est donc l'environnement global.

Mais il est possible que ça soit un autre environnement, par exemple l'*execution environment* d'une autre fonction (quand une deuxième fonction est définie dans une première fonction).

```{r}
f <- function() {
  g <- function(y) y^2
  environment(g)
}
```
L'*enclosing environment* de `f()` est l'environement global.
```{r}
environment(f)
```
L'*enclosing environment* de `g()` est l'*execution environment* de `f()`.
```{r}
f()
```

## Calling environment

C'est tout simplement l'environnement où la fonction est lancée. On peut l'obtenir avec `parent.frame()`.

```{r}
f <- function() {
  parent.frame()
}
```
Ici c'est donc l'environnement global:
```{r}
f()
```
Mais pour cette même fonction `f()`, si elle est lancée depuis `g()`, ça peut aussi être l'*execution environment* de `g()`.
```{r}
g <- function() {
  f()
}
g()
```

## Le lexical scoping

Ensemble de règles permettant à `R` de faire correspondre une valeur à un symbole.
```{r}
# x est le symbole, 10 est la valeur
x <- 10
f <- function() {
  x <- 20
  x
}

x
f()
```

## Le lexical scoping en détails (1/4)
### Parcours des environnements

Quand une variable n'est pas définie directement dans l'environnement de la fonction (*execution environment*), `R` va la chercher ailleurs.

Plus précisement, `R` va remonter progressivement le `searchpaths()` à la recherche d'une correspondance avec une variable/fonction portant ce nom.

Ici, la variable `x` est définie dans l'environnement de la fonction, donc R utilise cette correspondance :
```{r}
f <- function() {
  x <- 1
  x * 2
}

f()
```

## Le lexical scoping en détails (1/4)
Ici, la variable `x` n'est pas définie dans l'environnement de la fonction, mais dans son *enclosing environment*, l'environnement global. 

A l'exécution de la fonction `f`, `R` va d'abord chercher une correspondance pour `x` dans l'environnement de la fonction, puis va remonter à son *enclosing environment*, où il trouve une correspondance.
```{r}
x <- 10
f <- function() {
  print(x)
}

f()
```

## Le lexical scoping en détails (2/4)
### Fonctions VS variables

Une fonction et une variable, nommée à l'identique, ne sont pour autant pas les mêmes objets.
Ainsi, il est possible de manipuler des fonctions et des variables avec le même nom.

En fonction du contexte (appel d'une variable ou d'une fonction), `R` va chercher dans le type d'objet adéquat.

**ATTENTION : c'est pratique, mais c'est une potentielle source d'erreurs** (risque de confusion)

Ici, on crée un variable min correspondant à un vecteur
```{r}
min <- c(5:10)
min
```

`R` fait bien la distinction entre la fonction min() et la variable min
```{r}
min(min)
```

## Le lexical scoping en détails (3/4) {.reduceCode}
### Variables éphémères

Les variables définies dans l'environnement de la fonction n'existent et/ou ne sont manipulées que pendant la durée de l'exécution de la fonction, puis disparaissent à la fin de l'exécution.

Exemple : 
```{r}
f <- function() {
  x <- 1
  x * 2
}
```

Appels successifs de la fonction : x est créé, manipulé, puis détruit à chaque exécution
```{r}
f()
f()
```

## Le lexical scoping en détails (4/4) {.reduceCode}
### Evaluation à l'exécution

Les différentes variables utilisées par une fonction ne sont pas évalués lorsque la fonction est crée.
L'ensemble de ces éléments sont évaluée au **moment où la fonction est exécutée**.

Par conséquent, la valeur prise par une variable dans une fonction peut varier en fonction d'éléments extérieurs à la fonction (**attention, danger !**).

Exemple : 
```{r}
x <- 10
f <- function() {
 x^2
}

f()

x <- 100
f()
```

## La gestion des arguments

### Les arguments d'une fonction

Les arguments sont simplement **les paramètres d'une fonction**, définis et prévus au moment de sa création (on parle d'arguments *formels*). Une fois créé, on ne peut passer à la fonction que les arguments prévus.
 
Ici, `x` et `y` sont les arguements formels de `f` :
```{r}
f <- function(x, y) {
  # blah blah blah
}
```

Attention, le terme "arguments"" peut aussi faire référence aux **valeurs concrètes des paramètres d'une fonction** (on parle d'arguments **d'appel**). 

Ici, la fonction `f` est appelé en lui passant les arguments `10` et `20` :
```{r eval=F}
f(x = 10, y = 20)
```


## La gestion des arguments {.reduceCode}
### Les valeurs par défaut

Il est possible d'attribuer à un argument une valeur par défaut, et donc de le rendre optionnel :

- si une valeur est précisée lors de l'appel de la fonction, cette valeur sera utilisée
- si aucune valeur n'est donnée lors de l'appel, la valeur par défaut sera utilisée

```{r}
f <- function(x, more = FALSE) {
  print(length(x))
  if (more) print(class(x))
}
x <- c(1:5)
f(x)
f(x, more = TRUE)
```

## Les arguments

Une fonction peut avoir un nombre important d'arguments. Comment faire lors de l'appel d'une fonction pour attribuer la bonne valeur au bon argument ?

`R` fait appel à trois techniques possibles pour savoir à quel argument on fait référence dans l'appel d'une fonction :

- Matching par leur nom complet
- Matching par leur nom partiel
- Matching par leur position (ordre dans la définition de la fonction)

## Les arguments
```{r}
f <- function(foo, bar) {
  c(foo, bar)
}
```

Possiblité de donner les argument en :

- Utilisant leurs noms complets
```{r, results='hide'}
f(foo = 1 , bar = 2)
```

- Utilisant une partie de leur nom (*partial matching*)
```{r, results='hide'}
f(f = 1, b = 2) #A noter, le caractère confusiogène de f() la fonction et f le paramètre "raccourci"
```

- Utilisant leur position dans la définition de la fonction
```{r, results='hide'}
f(1, 2)
```

## Manipulation des arguments {.reduceCode}

La liste des arguments d'une fonction peut être récupérée avec `formals()`.

Cela permet de retrouver à la fois les arguments, et les valeurs par défaut. 

Exemple : 
```{r}
formals(sample)
```

## Manipulation des arguments {.reduceCode}

Il est possible de tester la présence/absence d'un argument avec `missing()`.
La fonction renvoie `TRUE` si l'argument n'a pas de valeur (et `FALSE` sinon).

Attention : `NULL` ou `NA` sont bien des valeurs...

```{r}
f <- function(x, y) {
  if (missing(y)) {
    return("La valeur y doit être précisée")
  }
  return("Les valeurs de x et y sont précisées")
}
```

```{r}
f(x = "foo", y = "bar")
f(x = "foo")
f(x = "foo", y = NULL)
```

## Lazy evaluation
L'évaluation d'un argument ne se fait qu'à l'instant *t* où l'argument est utilisé dans le corps de la fonction (et donc à l'instant *t* où l'évaluation devient nécessaire).
 
```{r}
f <- function(a = 1 , b = a * 2) {
  a <- 6
  b
}
```

L'évaluation de `b` ne se fait qu'au moment de son utilisation 
(donc ici après l'affectation de la valeur 6 à `a`)
```{r}
f()
```

## Dot Dot Dot (`...`) (1)

Argument spécial `...` qui permet de passer des arguments non spécifiés/déterminés à l'avance.

Utile dans deux cas :

- travailler sur un nombre arbitraire d'arguments.
```{r}
all_numeric <- function(...) {
  arguments <- list(...)
  all(unlist(lapply(arguments, is.numeric)))
}
all_numeric(2, c(1, 2, 3), 4:8)
```

## Dot Dot Dot (`...`) (2)

- faire passer des arguments à une fonction exécutée à l'intérieur d'une autre fonction, sans avoir à tous les nommer.
```{r}
mult_and_resamp <- function(x, y, ...) {
  x2 <- x * y
  sample(x2, ...)
}
mult_and_resamp(0:5, 10)
mult_and_resamp(0:2, 2, replace = TRUE, size = 10)
```

## Valeur de retour {.reduceCode}
Par défaut, une fonction retourne un objet **unique** qui peut être :

- le résultat de la dernière évaluation.
```{r}
f <- function(x) {
  x^2
}
f(2)
```
- un résultat précis, choisi, par l'intermédiaire de `return()` (force l'arrêt de la fonction).
```{r}
f <- function(x){
  if(x%%2 == 0){
    return("x est un nombre pair")
  }
  "x est un nombre impair"
}
f(4)
```

## Valeurs de retour complexes (1) {.reduceCode}

Comment faire pour retourner plus de choses ? Deux solutions :

- Tout mettre dans une liste.
```{r}
f <- function(x) {
  
  # opérations internes...
  
  return(list(
    # objets à retourner
  ))
}
```

## Valeurs de retour complexes (2) {.reduceCode}

- Utiliser des attributs.
```{r}
f <- function(x) {
  
  # opérations internes...
  
  attr(result, "nom_attribut") <- # contenu attribut
  return(result)
}
```
Avantage: le résultat continue à se comporter comme l'objet original (ici un vecteur), ce qui est parfois plus facile à utiliser qu'une liste.

## Définir plus facilement des attributs

Avec la fonction structure il est plus facile d'ajouter des attributs.
```{r}
f <- function(x) {
  res <- mean(x, na.rm = TRUE)
  
  structure(
    res,
    original_length = length(x),
    n_na = sum(is.na(x))
  )
}
f(c(1, 3, NA))
```

## Une fonction argument d'une fonction

On peut passer une fonction comme argument à une autre fonction. Ce concept est fondamental pour le cours suivant sur la famille de fonctions `apply()`.

```{r}
do_something_to_x <- function(x, func) {
  func(x)
}
do_something_to_x(1:10, mean)
do_something_to_x(1:10, range)
```

## Closures (1)
Le résultat d'une fonction est un objet. Une fonction est un objet comme un autre.

Une fonction peut donc renvoyer une autre fonction : ce sont les **closures**.
```{r}
f <- function(x){
  g <- function(y){
    x^y
  }
}
```

```{r}
carre <- f(2)
carre(2)

cube <- f(3)
cube(2)
```

## Closures (2)

Un exemple plus appliqué : un rééchantilloneur.
```{r}
create_resampler <- function(x) {
  function(n) sample(x, size = n, replace = TRUE)
}
rs1 <- create_resampler(1:10)
rs1(2)
rs1(9)
rs2 <- create_resampler(c("M", "F"))
rs2(5)
```

## Pour combiner les concepts (1) {.reduceCode}

Closure + *enclosing environment* + scoping. On fait un compteur.
```{r}
create_counter <- function() {
  n <- 0
  function() {
    n <<- n + 1
    return(n)
  }
}
c1 <- create_counter()
c1()
c1()
```
Le compteur n'est pas partagé car si on appelle à nouveau `create_counter()`, un second *execution environment* indépendant est créé.
```{r}
c2 <- create_counter()
c2()
c1()
```

## Pour combiner les concepts (2) {.reduceCode}

Il faut remonter d'un niveau l'*enclosing environment* pour partager le compteur.
```{r}
# local() permet de créer un nouvel environment
create_counter <- local({
  n <- 0
  function() {
    function() {
      n <<- n + 1
      return(n)
    }
  }
})
c1 <- create_counter()
c1()
c2 <- create_counter()
c2()
c1()
```
